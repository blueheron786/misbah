using Bunit;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Misbah.BlazorDesktop.Components.Pages.Notes;
using Misbah.Core.Services;
using Misbah.Core.Models;
using Microsoft.JSInterop;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Threading;
using System.Linq;

namespace Misbah.BlazorDesktop.Tests
{
    public class TrueLiveMarkdownEditorComprehensiveTests : Bunit.TestContext
    {
        private TestMarkdownRenderer _mockRenderer;

        public TrueLiveMarkdownEditorComprehensiveTests()
        {
            _mockRenderer = new TestMarkdownRenderer();
            Services.AddSingleton<MarkdownRenderer>(_mockRenderer);
            Services.AddSingleton<IJSRuntime>(new MockJSRuntime());
        }

        #region Editability Tests - Critical for preventing regressions

        [Test]
        public void EmptyNote_ShowsPlaceholder_IsClickable()
        {
            // Arrange & Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, ""));

            // Assert - Empty notes should show clickable placeholder
            var placeholder = component.Find(".empty-placeholder");
            Assert.That(placeholder, Is.Not.Null);
            Assert.That(placeholder.TextContent, Does.Contain("Click here to start writing"));
            
            // Should be clickable to start editing
            Assert.That(placeholder.HasAttribute("onclick", Is.True) || placeholder.GetClasses().Contains("clickable"));
        }

        [Test]
        public void EmptyNote_ClickPlaceholder_EntersEditMode()
        {
            // Arrange
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, ""));

            // Act - Click placeholder to start editing
            var placeholder = component.Find(".empty-placeholder");
            placeholder.Click();

            // Assert - Should enter edit mode with textarea
            var textarea = component.Find("textarea");
            Assert.That(textarea, Is.Not.Null);
            Assert.That(textarea.GetClasses(), Does.Contain("block-textarea"));
        }

        [Test]
        public void NonEmptyNote_RendersBlocks_AllClickableForEdit()
        {
            // Arrange
            var content = "# Header\n\nThis is a paragraph.\n\n## Another header";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should render blocks, all clickable for editing
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count >= 2, "Should have multiple blocks", Is.True);
            
            foreach (var block in blocks)
            {
                var displayDiv = block.QuerySelector(".block-display");
                Assert.That(displayDiv, Is.Not.Null);
                // Each block should be clickable to enter edit mode
                Assert.That(displayDiv.HasAttribute("onclick", Is.True));
            }
        }

        [Test]
        public void ClickBlock_EntersEditMode_ShowsTextarea()
        {
            // Arrange
            var content = "# Header\n\nThis is a paragraph.";
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Act - Click first block to edit
            var firstBlock = component.Find(".block-display");
            firstBlock.Click();

            // Assert - Should show textarea in edit mode
            var textarea = component.Find("textarea");
            Assert.That(textarea, Is.Not.Null);
            Assert.That(textarea.GetClasses(), Does.Contain("block-textarea"));
            
            // Should show edit controls
            var saveBtn = component.Find(".btn-save");
            var cancelBtn = component.Find(".btn-cancel");
            Assert.That(saveBtn, Is.Not.Null);
            Assert.That(cancelBtn, Is.Not.Null);
        }

        #endregion

        #region Rendering Tests - Prevent rendering breakage

        [Test]
        public void ParseContentIntoBlocks_HandlesHeaders_Correctly()
        {
            // Arrange
            var content = "# H1\n## H2\n### H3\n#### H4\n##### H5\n###### H6";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should parse all header levels
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count, Is.EqualTo(6));
            
            // Verify each block has correct type
            var expectedTypes = new[] { "h1", "h2", "h3", "h4", "h5", "h6" };
            for (int i = 0; i < blocks.Count; i++)
            {
                Assert.That(blocks[i].GetAttribute("data-block-type", Is.EqualTo(expectedTypes[i])));
            }
        }

        [Test]
        public void ParseContentIntoBlocks_HandlesCodeBlocks_Correctly()
        {
            // Arrange
            var content = "Some text\n\n```csharp\nvar x = 5;\nConsole.WriteLine(x);\n```\n\nMore text";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should parse code blocks correctly
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count, Is.EqualTo(3));
            
            // Middle block should be code
            Assert.That(blocks[1].GetAttribute("data-block-type", Is.EqualTo("code")));
        }

        [Test]
        public void ParseContentIntoBlocks_HandlesLists_Correctly()
        {
            // Arrange
            var content = "- Item 1\n- Item 2\n- Item 3\n\n1. Numbered 1\n2. Numbered 2";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should parse both unordered and ordered lists
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count, Is.EqualTo(2));
            Assert.That(blocks[0].GetAttribute("data-block-type", Is.EqualTo("list")));
            Assert.That(blocks[1].GetAttribute("data-block-type", Is.EqualTo("ordered-list")));
        }

        [Test]
        public void ParseContentIntoBlocks_HandlesQuotes_Correctly()
        {
            // Arrange
            var content = "> This is a quote\n> Multi-line quote\n\nRegular paragraph";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should parse quotes correctly
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count, Is.EqualTo(2));
            Assert.That(blocks[0].GetAttribute("data-block-type", Is.EqualTo("quote")));
            Assert.That(blocks[1].GetAttribute("data-block-type", Is.EqualTo("paragraph")));
        }

        [Test]
        public void ParseContentIntoBlocks_HandlesTaskLists_Correctly()
        {
            // Arrange
            var content = "- [ ] Unchecked task\n- [x] Checked task\n- [ ] Another task";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should parse task lists correctly
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count(), Is.EqualTo(1));
            Assert.That(blocks[0].GetAttribute("data-block-type", Is.EqualTo("task")));
        }

        [Test]
        public void RenderBlockToHtml_CallsMarkdownRenderer_ForAllBlocks()
        {
            // Arrange
            var content = "# Header\n\nParagraph text\n\n```code\nvar x = 1;\n```";
            _mockRenderer.ClearCallLog();
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - MarkdownRenderer should be called for each block
            Assert.That(_mockRenderer.RenderCallCount >= 3, $"Expected at least 3 render calls, got {_mockRenderer.RenderCallCount}", Is.True);
            Assert.That(_mockRenderer.RenderedContent.Any(c => c.Contains("Header", Is.True)));
            Assert.That(_mockRenderer.RenderedContent.Any(c => c.Contains("Paragraph", Is.True)));
            Assert.That(_mockRenderer.RenderedContent.Any(c => c.Contains("var x", Is.True)));
        }

        #endregion

        #region Edit/Save Tests - Critical for data integrity

        [Test]
        public void SaveBlock_UpdatesContent_NotifiesParent()
        {
            // Arrange
            var originalContent = "# Original Header\n\nOriginal paragraph";
            string? changedContent = null;
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, originalContent)
                .Add(p => p.ContentChanged, EventCallback.Factory.Create<string>(this, content => changedContent = content)));

            // Act - Enter edit mode and modify content
            var firstBlock = component.Find(".block-display");
            firstBlock.Click();
            
            var textarea = component.Find("textarea");
            textarea.Change("# Modified Header");
            
            var saveBtn = component.Find(".btn-save");
            saveBtn.Click();

            // Assert - Parent should be notified of content change
            Assert.That(changedContent, Is.Not.Null);
            Assert.That(changedContent, Does.Contain("Modified Header"));
            Assert.That(changedContent, Does.Not.Contain("Original Header"));
        }

        [Test]
        public void CancelEdit_RestoresOriginalContent_NoParentNotification()
        {
            // Arrange
            var originalContent = "# Original Header";
            string? changedContent = null;
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, originalContent)
                .Add(p => p.ContentChanged, EventCallback.Factory.Create<string>(this, content => changedContent = content)));

            // Act - Enter edit mode, modify, then cancel
            var firstBlock = component.Find(".block-display");
            firstBlock.Click();
            
            var textarea = component.Find("textarea");
            textarea.Change("# Modified Header");
            
            var cancelBtn = component.Find(".btn-cancel");
            cancelBtn.Click();

            // Assert - No parent notification, original content preserved
            Assert.That(changedContent, Is.Null);
            var restoredBlock = component.Find(".block-display");
            Assert.That(restoredBlock.InnerHtml, Does.Contain("Original Header"));
        }

        [Test]
        public void CreateNewBlock_AddsBlock_EntersEditMode()
        {
            // Arrange
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, "# Existing header"));

            // Act - Click add new block
            var addBtn = component.Find(".add-new-block");
            addBtn.Click();

            // Assert - Should add new block in edit mode
            var textarea = component.Find("textarea");
            Assert.That(textarea, Is.Not.Null);
            Assert.That(textarea.GetAttribute("value", Is.Empty) ?? "");
        }

        [Test]
        public void MultipleBlocks_SaveOne_PreservesOthers()
        {
            // Arrange
            var originalContent = "# Header 1\n\nParagraph 1\n\n# Header 2\n\nParagraph 2";
            string? changedContent = null;
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, originalContent)
                .Add(p => p.ContentChanged, EventCallback.Factory.Create<string>(this, content => changedContent = content)));

            // Act - Edit only the first block
            var blocks = component.FindAll(".block-display");
            blocks[0].Click(); // Edit first block
            
            var textarea = component.Find("textarea");
            textarea.Change("# Modified Header 1");
            
            var saveBtn = component.Find(".btn-save");
            saveBtn.Click();

            // Assert - Other blocks should remain unchanged
            Assert.That(changedContent, Is.Not.Null);
            Assert.That(changedContent, Does.Contain("Modified Header 1"));
            Assert.That(changedContent, Does.Contain("Paragraph 1"));
            Assert.That(changedContent, Does.Contain("Header 2"));
            Assert.That(changedContent, Does.Contain("Paragraph 2"));
        }

        #endregion

        #region Keyboard Interaction Tests

        [Test]
        public void CtrlEnter_InEditMode_SavesBlock()
        {
            // Arrange
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, "# Test Header"));

            var firstBlock = component.Find(".block-display");
            firstBlock.Click();

            // Act - Press Ctrl+Enter
            var textarea = component.Find("textarea");
            textarea.KeyDown(new Microsoft.AspNetCore.Components.Web.KeyboardEventArgs
            {
                Key = "Enter",
                CtrlKey = true
            });

            // Assert - Should exit edit mode (no textarea visible)
            Assert.Throws<ElementNotFoundException>(() => component.Find("textarea"));
        }

        [Test]
        public void Escape_InEditMode_CancelsEdit()
        {
            // Arrange
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, "# Test Header"));

            var firstBlock = component.Find(".block-display");
            firstBlock.Click();

            // Act - Press Escape
            var textarea = component.Find("textarea");
            textarea.KeyDown(new Microsoft.AspNetCore.Components.Web.KeyboardEventArgs
            {
                Key = "Escape"
            });

            // Assert - Should exit edit mode
            Assert.Throws<ElementNotFoundException>(() => component.Find("textarea"));
        }

        #endregion

        #region Textarea Styling Tests

        [Test]
        public void GetTextareaStyle_HeaderBlocks_HaveCorrectFontSizes()
        {
            // Arrange
            var content = "# H1\n## H2\n### H3";
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Act & Assert - Test each header level
            var blocks = component.FindAll(".block-display");
            
            // Click H1 block
            blocks[0].Click();
            var textarea = component.Find("textarea");
            var style = textarea.GetAttribute("style") ?? "";
            Assert.That(style, Does.Contain("font-size: 2em"));
            
            // Cancel and test H2
            component.Find(".btn-cancel").Click();
            blocks[1].Click();
            textarea = component.Find("textarea");
            style = textarea.GetAttribute("style") ?? "";
            Assert.That(style, Does.Contain("font-size: 1.5em"));
        }

        [Test]
        public void GetTextareaStyle_CodeBlocks_HaveMonospaceFont()
        {
            // Arrange
            var content = "```csharp\nvar x = 5;\n```";
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Act - Click code block
            var codeBlock = component.Find(".block-display");
            codeBlock.Click();

            // Assert - Should have monospace font
            var textarea = component.Find("textarea");
            var style = textarea.GetAttribute("style") ?? "";
            Assert.That(style, Does.Contain("Consolas"));
            Assert.That(style, Does.Contain("Monaco"));
            Assert.That(style, Does.Contain("monospace"));
        }

        #endregion

        #region Regression Prevention Tests

        [Test]
        public void ContentWithSpecialCharacters_RendersCorrectly()
        {
            // Arrange - Content with characters that could break rendering
            var content = "# Header with <special> & chars\n\n\"Quotes\" and 'apostrophes'\n\n&lt;escaped&gt; HTML";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should render without throwing exceptions
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count > 0, "Should render blocks despite special characters", Is.True);
        }

        [Test]
        public void VeryLongContent_RendersCorrectly()
        {
            // Arrange - Very long content that could cause performance issues
            var longParagraph = string.Join(" ", Enumerable.Repeat("This is a very long paragraph with many words.", 100));
            var content = $"# Header\n\n{longParagraph}\n\n## Another section\n\n{longParagraph}";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should handle long content
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count > 0, "Should render long content", Is.True);
        }

        [Test]
        public void EmptyLines_HandleCorrectly()
        {
            // Arrange - Content with multiple empty lines
            var content = "# Header\n\n\n\n\nParagraph after many empty lines\n\n\n## Another header";
            
            // Act
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));

            // Assert - Should handle empty lines gracefully
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count >= 3, "Should create appropriate blocks despite empty lines", Is.True);
        }

        [Test]
        public void MixedLineEndings_HandleCorrectly()
        {
            // Arrange - Content with mixed line endings (could happen with copy/paste)
            var content = "# Header\r\n\r\nWindows line ending\n\nUnix line ending\r\nMixed content";
            
            // Act & Assert - Should not throw exceptions
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, content));
            
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count > 0, "Should handle mixed line endings", Is.True);
        }

        [Test]
        public void ContentParameterChange_UpdatesBlocks()
        {
            // Arrange
            var component = RenderComponent<TrueLiveMarkdownEditor>(parameters => parameters
                .Add(p => p.Content, "# Original"));

            // Act - Change content parameter
            component.SetParametersAndRender(parameters => parameters
                .Add(p => p.Content, "# Updated\n\nNew paragraph"));

            // Assert - Should re-parse and update blocks
            var blocks = component.FindAll(".live-block");
            Assert.That(blocks.Count, Is.EqualTo(2));
        }

        #endregion

        #region Mock Classes

        private class TestMarkdownRenderer : MarkdownRenderer
        {
            public int RenderCallCount { get; private set; }
            public List<string> RenderedContent { get; } = new();

            public TestMarkdownRenderer() : base()
            {
            }

            public new string Render(string markdownText, out List<int> taskLines)
            {
                RenderCallCount++;
                RenderedContent.Add(markdownText);
                taskLines = new List<int>();
                
                // Simple mock rendering - just wrap in <p> or appropriate tag
                if (markdownText.StartsWith("# "))
                    return $"<h1>{markdownText[2..]}</h1>";
                if (markdownText.StartsWith("## "))
                    return $"<h2>{markdownText[3..]}</h2>";
                if (markdownText.StartsWith("### "))
                    return $"<h3>{markdownText[4..]}</h3>";
                if (markdownText.StartsWith("> "))
                    return $"<blockquote>{markdownText[2..]}</blockquote>";
                if (markdownText.StartsWith("```"))
                    return $"<pre><code>{markdownText}</code></pre>";
                
                return $"<p>{markdownText}</p>";
            }

            public void ClearCallLog()
            {
                RenderCallCount = 0;
                RenderedContent.Clear();
            }
        }

        private class MockJSRuntime : IJSRuntime
        {
            public ValueTask<TValue> InvokeAsync<TValue>(string identifier, object?[]? args)
            {
                return ValueTask.FromResult<TValue>(default(TValue)!);
            }

            public ValueTask<TValue> InvokeAsync<TValue>(string identifier, CancellationToken cancellationToken, object?[]? args)
            {
                return ValueTask.FromResult<TValue>(default(TValue)!);
            }
        }

        #endregion
    }
}
