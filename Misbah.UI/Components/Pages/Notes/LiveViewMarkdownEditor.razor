@using Misbah.Core.Models
@using Misbah.Core.Services
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime
@inject MarkdownRenderer MarkdownRenderer
@implements IAsyncDisposable

<div class="live-view-editor @(Theme == "dark" ? "dark" : "")" style="height: @Height; overflow-y: auto; padding: 20px; line-height: 1.6;">
    @if (string.IsNullOrEmpty(Content))
    {
        <div class="empty-content" @onclick="() => StartEditingBlock(0, string.Empty)">
            <p class="text-muted">Click here to start writing...</p>
        </div>
    }
    else
    {
        @for (int blockIndex = 0; blockIndex < contentBlocks.Count; blockIndex++)
        {
            var block = contentBlocks[blockIndex];
            var currentBlockIndex = blockIndex; // Capture for closure
            
            <div class="content-block @(editingBlockIndex == currentBlockIndex ? "editing" : "")" 
                 data-block-index="@currentBlockIndex">
                @if (editingBlockIndex == currentBlockIndex)
                {
                    <!-- Inline editing mode -->
                    <div class="inline-editor">
                        <textarea @ref="inlineTextArea"
                                  @bind="editingContent"
                                  @onblur="() => FinishEditing()"
                                  @onkeydown="HandleEditorKeyDown"
                                  @oninput="OnEditorInput"
                                  class="block-editor"
                                  placeholder="@GetPlaceholderText(block.Type)"
                                  style="@GetEditorStyle(block.Type)"></textarea>
                        <div class="editor-controls">
                            <button class="btn-save" @onclick="() => FinishEditing()">
                                <i class="fas fa-check"></i>
                            </button>
                            <button class="btn-cancel" @onclick="() => CancelEditing()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                }
                else
                {
                    <!-- Rendered view mode -->
                    <div class="rendered-block @GetBlockCssClass(block.Type)" 
                         @onclick="() => StartEditingBlock(currentBlockIndex, block.RawContent)"
                         title="Click to edit">
                        @((MarkupString)block.RenderedContent)
                    </div>
                }
            </div>
        }
        
        <!-- Add new block button -->
        <div class="add-block" @onclick="() => AddNewBlock()">
            <i class="fas fa-plus"></i> Add content
        </div>
    }
</div>

@code {
    [Parameter] public string Content { get; set; } = "";
    [Parameter] public EventCallback<string> ContentChanged { get; set; }
    [Parameter] public string Height { get; set; } = "600px";
    [Parameter] public string Theme { get; set; } = "light";

    private List<ContentBlock> contentBlocks = new();
    private int editingBlockIndex = -1;
    private string editingContent = "";
    private ElementReference inlineTextArea;
    private DotNetObjectReference<LiveViewMarkdownEditor>? dotNetRef;

    public class ContentBlock
    {
        public ContentBlockType Type { get; set; }
        public string RawContent { get; set; } = "";
        public string RenderedContent { get; set; } = "";
        public int StartLine { get; set; }
        public int EndLine { get; set; }
    }

    public enum ContentBlockType
    {
        Paragraph,
        Heading1,
        Heading2,
        Heading3,
        Heading4,
        Heading5,
        Heading6,
        CodeBlock,
        Quote,
        List,
        TaskList,
        HorizontalRule,
        Table
    }

    protected override Task OnInitializedAsync()
    {
        dotNetRef = DotNetObjectReference.Create(this);
        ParseContentIntoBlocks();
        return Task.CompletedTask;
    }

    protected override Task OnParametersSetAsync()
    {
        if (editingBlockIndex == -1) // Only reparse if not currently editing
        {
            ParseContentIntoBlocks();
        }
        return Task.CompletedTask;
    }

    private void ParseContentIntoBlocks()
    {
        contentBlocks.Clear();
        
        if (string.IsNullOrEmpty(Content))
            return;

        var lines = Content.Split('\n');
        var currentBlock = new List<string>();
        var currentType = ContentBlockType.Paragraph;
        int lineIndex = 0;

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i].TrimEnd();
            var blockType = DetermineBlockType(line);
            
            // Check if we need to start a new block
            if (ShouldStartNewBlock(currentType, blockType, line, currentBlock))
            {
                if (currentBlock.Count > 0)
                {
                    AddContentBlock(currentType, currentBlock, lineIndex);
                    lineIndex += currentBlock.Count;
                    currentBlock.Clear();
                }
                currentType = blockType;
            }

            currentBlock.Add(line);
        }

        // Add the final block
        if (currentBlock.Count > 0)
        {
            AddContentBlock(currentType, currentBlock, lineIndex);
        }
    }

    private ContentBlockType DetermineBlockType(string line)
    {
        if (string.IsNullOrWhiteSpace(line))
            return ContentBlockType.Paragraph;

        var trimmed = line.Trim();
        
        if (trimmed.StartsWith("# ")) return ContentBlockType.Heading1;
        if (trimmed.StartsWith("## ")) return ContentBlockType.Heading2;
        if (trimmed.StartsWith("### ")) return ContentBlockType.Heading3;
        if (trimmed.StartsWith("#### ")) return ContentBlockType.Heading4;
        if (trimmed.StartsWith("##### ")) return ContentBlockType.Heading5;
        if (trimmed.StartsWith("###### ")) return ContentBlockType.Heading6;
        if (trimmed.StartsWith("```")) return ContentBlockType.CodeBlock;
        if (trimmed.StartsWith("> ")) return ContentBlockType.Quote;
        if (trimmed.StartsWith("- [ ]") || trimmed.StartsWith("- [x]")) return ContentBlockType.TaskList;
        if (trimmed.StartsWith("- ") || trimmed.StartsWith("* ") || trimmed.StartsWith("+ ")) return ContentBlockType.List;
        if (trimmed.StartsWith("---") || trimmed.StartsWith("***")) return ContentBlockType.HorizontalRule;
        if (trimmed.Contains("|")) return ContentBlockType.Table;
        
        return ContentBlockType.Paragraph;
    }

    private bool ShouldStartNewBlock(ContentBlockType currentType, ContentBlockType newType, string line, List<string> currentBlock)
    {
        // Always start new block for different types
        if (currentType != newType && currentBlock.Count > 0)
            return true;

        // Start new block for headings (each heading is its own block)
        if (newType >= ContentBlockType.Heading1 && newType <= ContentBlockType.Heading6)
            return currentBlock.Count > 0;

        // Start new block after empty lines for paragraphs
        if (currentType == ContentBlockType.Paragraph && string.IsNullOrWhiteSpace(line) && currentBlock.Count > 0)
            return true;

        return false;
    }

    private void AddContentBlock(ContentBlockType type, List<string> lines, int startLine)
    {
        var rawContent = string.Join("\n", lines);
        var renderedContent = RenderBlock(type, rawContent);
        
        contentBlocks.Add(new ContentBlock
        {
            Type = type,
            RawContent = rawContent,
            RenderedContent = renderedContent,
            StartLine = startLine,
            EndLine = startLine + lines.Count - 1
        });
    }

    private string RenderBlock(ContentBlockType type, string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return "<p><br></p>";

        // Use the existing MarkdownRenderer
        var html = MarkdownRenderer.RenderFull(content, out var _);
        
        // Clean up extra paragraph tags for inline elements
        if (type >= ContentBlockType.Heading1 && type <= ContentBlockType.Heading6)
        {
            html = html.Replace("<p>", "").Replace("</p>", "");
        }

        return html;
    }

    private async Task StartEditingBlock(int blockIndex, string content)
    {
        editingBlockIndex = blockIndex;
        editingContent = content;
        StateHasChanged();
        
        // Use JavaScript helpers for better editing experience
        await Task.Delay(50); // Allow UI to update
        await JSRuntime.InvokeVoidAsync("liveViewMarkdownHelpers.initializeEditor", ".block-editor", dotNetRef);
    }

    [JSInvokable]
    public async Task FinishEditing()
    {
        if (editingBlockIndex >= 0 && editingBlockIndex < contentBlocks.Count)
        {
            // Update the block
            var block = contentBlocks[editingBlockIndex];
            block.RawContent = editingContent;
            block.Type = DetermineBlockType(editingContent.Split('\n')[0]);
            block.RenderedContent = RenderBlock(block.Type, editingContent);
            
            // Rebuild full content and notify parent
            await UpdateFullContent();
        }
        
        editingBlockIndex = -1;
        editingContent = "";
        StateHasChanged();
    }

    [JSInvokable]
    public void CancelEditing()
    {
        editingBlockIndex = -1;
        editingContent = "";
        StateHasChanged();
    }

    private async Task OnEditorInput()
    {
        // Auto-resize is handled by JavaScript helpers
        await Task.CompletedTask;
    }

    private async Task AddNewBlock()
    {
        var newBlock = new ContentBlock
        {
            Type = ContentBlockType.Paragraph,
            RawContent = "",
            RenderedContent = "",
            StartLine = contentBlocks.Count,
            EndLine = contentBlocks.Count
        };
        
        contentBlocks.Add(newBlock);
        await StartEditingBlock(contentBlocks.Count - 1, "");
    }

    private async Task UpdateFullContent()
    {
        var fullContent = string.Join("\n", contentBlocks.Select(b => b.RawContent));
        Content = fullContent;
        
        if (ContentChanged.HasDelegate)
        {
            await ContentChanged.InvokeAsync(fullContent);
        }
    }

    private async Task HandleEditorKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && e.CtrlKey)
        {
            await FinishEditing();
        }
        else if (e.Key == "Escape")
        {
            CancelEditing();
        }
    }

    private string GetBlockCssClass(ContentBlockType type)
    {
        return type switch
        {
            ContentBlockType.Heading1 => "block-h1",
            ContentBlockType.Heading2 => "block-h2",
            ContentBlockType.Heading3 => "block-h3",
            ContentBlockType.Heading4 => "block-h4",
            ContentBlockType.Heading5 => "block-h5",
            ContentBlockType.Heading6 => "block-h6",
            ContentBlockType.CodeBlock => "block-code",
            ContentBlockType.Quote => "block-quote",
            ContentBlockType.List => "block-list",
            ContentBlockType.TaskList => "block-tasks",
            ContentBlockType.Table => "block-table",
            _ => "block-paragraph"
        };
    }

    private string GetPlaceholderText(ContentBlockType type)
    {
        return type switch
        {
            ContentBlockType.Heading1 => "# Heading 1",
            ContentBlockType.Heading2 => "## Heading 2", 
            ContentBlockType.Heading3 => "### Heading 3",
            ContentBlockType.Heading4 => "#### Heading 4",
            ContentBlockType.Heading5 => "##### Heading 5",
            ContentBlockType.Heading6 => "###### Heading 6",
            ContentBlockType.CodeBlock => "```\ncode here\n```",
            ContentBlockType.Quote => "> Quote text",
            ContentBlockType.List => "- List item",
            ContentBlockType.TaskList => "- [ ] Task item",
            _ => "Type your content here..."
        };
    }

    private string GetEditorStyle(ContentBlockType type)
    {
        var baseStyle = "resize: none; border: none; outline: none; background: transparent; font-family: inherit; width: 100%; min-height: 40px;";
        
        return type switch
        {
            ContentBlockType.Heading1 => baseStyle + " font-size: 2rem; font-weight: bold;",
            ContentBlockType.Heading2 => baseStyle + " font-size: 1.5rem; font-weight: bold;",
            ContentBlockType.Heading3 => baseStyle + " font-size: 1.25rem; font-weight: bold;",
            ContentBlockType.Heading4 => baseStyle + " font-size: 1.1rem; font-weight: bold;",
            ContentBlockType.Heading5 => baseStyle + " font-size: 1rem; font-weight: bold;",
            ContentBlockType.Heading6 => baseStyle + " font-size: 0.9rem; font-weight: bold;",
            ContentBlockType.CodeBlock => baseStyle + " font-family: 'Consolas', 'Monaco', monospace; background: #f8f9fa;",
            _ => baseStyle
        };
    }

    public ValueTask DisposeAsync()
    {
        dotNetRef?.Dispose();
        return ValueTask.CompletedTask;
    }
}
